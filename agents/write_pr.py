import os
import shutil
import requests
import git
from agents.state import AgentState

def write_pr(state: AgentState) -> AgentState:
    task = state.get("task")
    code = state.get("code")
    github_repo = state.get("github_repo")
    github_token = os.getenv("GITHUB_TOKEN")

    if not all([task, code, github_repo, github_token]):
        print("âŒ Missing required inputs: task/code/github_repo/token")
        state["pr_status"] = "PR Failed: Missing input"
        return state

    local_path = state.get("local_path")
    backup_files = {}

    # Backup all files if path exists (before deleting non-git folder)
    if os.path.exists(local_path):
        try:
            _ = git.Repo(local_path)  # try to open as repo
        except git.exc.InvalidGitRepositoryError:
            print(f"ğŸ“¥ Cloning {github_repo} to {local_path} (folder is not a valid Git repo)...")

            for fname in os.listdir(local_path):
                fpath = os.path.join(local_path, fname)
                if os.path.isfile(fpath):
                    with open(fpath, "r", encoding="utf-8") as f:
                        backup_files[fname] = f.read()

            shutil.rmtree(local_path)  # remove non-git folder

    # Clone repo
    if not os.path.exists(local_path):
        repo_url = f"https://{github_token}@github.com/{github_repo}.git"
        repo = git.Repo.clone_from(repo_url, local_path)
    else:
        repo = git.Repo(local_path)

    # Restore backed-up files
    for fname, content in backup_files.items():
        with open(os.path.join(local_path, fname), "w", encoding="utf-8") as f:
            f.write(content)
        print(f"ğŸ” Restored file: {fname}")

    state["local_path"] = local_path

    branch_name = input("ğŸ”€ Enter a branch name: ").strip()
    if branch_name in repo.heads:
        print(f"â™»ï¸ Branch '{branch_name}' already exists. Reusing it.")
        new_branch = repo.heads[branch_name]
    else:
        new_branch = repo.create_head(branch_name)
    new_branch.checkout()

    print("\nğŸ“‚ You can now upload files to push. Paste full file paths, one per line. Leave blank to skip.")
    file_paths = []
    while True:
        path = input("ğŸ“ File path (ENTER to stop): ").strip()
        if not path:
            break

        if os.path.exists(path):
            dest_path = os.path.join(local_path, os.path.basename(path))
            if os.path.abspath(path) == os.path.abspath(dest_path):
                print(f"âš ï¸ Skipped copying '{path}' (source and destination are the same).")
                continue

            if os.path.isdir(path):
                shutil.copytree(path, dest_path, dirs_exist_ok=True)
                print(f"ğŸ“ Copied folder: {path}")
            else:
                shutil.copy(path, dest_path)
                print(f"ğŸ“„ Copied file: {path}")
            file_paths.append(os.path.basename(path))

        else:
            print("âš ï¸ File does not exist.")

    if not file_paths:
        generated_file_name = state.get("generated_file_name", "generated_code.py")
        fallback_path = os.path.join(local_path, generated_file_name)
        with open(fallback_path, "w", encoding="utf-8") as f:
            f.write(code)
        file_paths.append(generated_file_name)

    readme_path = os.path.join(local_path, "README.md")
    gitignore_path = os.path.join(local_path, ".gitignore")

    if not os.path.exists(readme_path):
        with open(readme_path, "w") as f:
            f.write(f"# Project for task: {task}\n\nAuto-generated by Project Buddy.\n")
        file_paths.append("README.md")

    if not os.path.exists(gitignore_path):
        with open(gitignore_path, "w") as f:
            f.write("__pycache__/\n*.pyc\n.env\n")
        file_paths.append(".gitignore")

    repo.git.add(A=True)
    if repo.is_dirty(untracked_files=True):
        print("ğŸ“¦ Files staged for commit:")
        print(repo.git.status('--short'))

        repo.index.commit(f"feat: add files for task - {task}")
        repo.remote(name="origin").push(refspec=f"{branch_name}:{branch_name}")
        print(f"âœ… Code committed and pushed to `{branch_name}`")
    else:
        print("âš ï¸ No changes to commit.")
        state["pr_status"] = "PR Failed: No changes to commit."
        return state

    headers = {
        "Authorization": f"Bearer {github_token}",
        "Accept": "application/vnd.github+json"
    }

    # Check if PR already exists
    pr_check_url = f"https://api.github.com/repos/{github_repo}/pulls?head={github_repo.split('/')[0]}:{branch_name}"
    check_response = requests.get(pr_check_url, headers=headers)
    pr_url = None

    if check_response.status_code == 200 and check_response.json():
        pr_url = check_response.json()[0]["html_url"]
        print("â™»ï¸ Pull Request already exists. Updating branch only.")
        state["pr_status"] = f"âœ… Updated existing PR: {pr_url}"
    else:
        # Create PR
        payload = {
            "title": f"Auto PR: {task}",
            "body": "PR auto-generated by Project Buddy.",
            "head": branch_name,
            "base": "main"
        }
        pr_response = requests.post(
            f"https://api.github.com/repos/{github_repo}/pulls",
            headers=headers,
            json=payload
        )

        if pr_response.status_code == 201:
            pr_url = pr_response.json()["html_url"]
            print("ğŸ‰ Pull Request Created:", pr_url)
            state["pr_status"] = f"PR Created: {pr_url}"
        else:
            print("âŒ PR Failed:", pr_response.status_code, pr_response.text)
            state["pr_status"] = f"PR Failed: {pr_response.status_code} - {pr_response.text}"

    return {
        "local_path": local_path,
        "pr_status": state["pr_status"]
    }

